✅ 高低位分析
==============

## 已知數據

實際抓取的字節: `87 00 09`

## 解析

```
87 = 0x87 = 135 (十進位)
00 = 0x00 = 0
09 = 0x09 = 9 (十進位)
```

## 問題分析

我之前的公式:
```javascript
const plays = bytes[36] | (bytes[37] << 8);    // 0x87 | (0x00 << 8) = 135 ✅
const payouts = bytes[38] | (bytes[39] << 8);  // 0x09 | (0x00 << 8) = 9 ✅
```

這應該是正確的！但截圖顯示 350 和 90，這表示：

## 🔍 真相

您說的 `87 00 09` 實際上應該理解為：

```
87 00 = 0x0087 (Little-Endian) = 135
09 ?? = 0x00?? (需要下一個字節)
```

**但截圖顯示 350 和 90**

讓我反推：
```
350 = 0x015E 
  Little-Endian: 5E 01
  Big-Endian: 01 5E

90 = 0x005A
  Little-Endian: 5A 00
  Big-Endian: 00 5A
```

所以如果看到 `87 00 09`，但結果是 350 和 90，說明：

**可能是 Big-Endian，而不是 Little-Endian！**

```javascript
// Big-Endian 解析
const plays = (bytes[36] << 8) | bytes[37];    // (0x87 << 8) | 0x00 = 34560 ❌ 不對

// 或者位置不同
const plays = (bytes[35] << 8) | bytes[36];    // (0x5E << 8) | 0x01 ❌ 還是不對
```

---

## ✅ 真正的解決方案

請提供完整 parm，我來找 `87 00 09` 的確切位置，然後確認應該用:

1. `bytes[i] | (bytes[i+1] << 8)` (Little-Endian)
2. `(bytes[i] << 8) | bytes[i+1]` (Big-Endian)
3. 還是完全不同的位置

**請複製新的完整 parm 十六進位字符串！**
