🔍 parm 數據反向工程分析
=======================

## 📊 您提供的實際數據

```
parm: "02020a5e010002010001000201000a00000000000000830628210b000128000087000900d2005e015a00780046000e0128000000140000000000323232320a0a00"

長度: 126 字符 = 63 字節
```

## 🔬 逐位分析

### 字節分解 (十進位)

```
位置  十六進位  十進位  字符  說明
─────────────────────────────────────
0-3   02 02    2, 2     -     標頭
4-7   0a 5e    10, 94   -     
8-11  01 00    1, 0     -     
12-15 02 01    2, 1     -     
...
16-19 00 00    0, 0     -     
20-23 00 0a    0, 10    -     
24-27 00 00    0, 0     -     
28-31 00 00    0, 0     -     標頭結束?
32-35 83 06    131, 6   -     可能的數據開始
36-39 28 21    40, 33   -     
40-43 0b 00    11, 0    -     
44-47 01 28    1, 40    -     
48-51 00 00    0, 0     -     
52-55 87 00    135, 0   -     ⭐ 可能是出獎數據
...
```

## 🧮 可能的數據位置組合

### Little-Endian 4字節組合分析

使用 Little-Endian (低字節優先) 轉換為整數：

```
位置  公式                          結果        說明
────────────────────────────────────────────────────────────
0-3   02 + (02<<8)                  514        
4-7   0a + (5e<<8)                  24074      
8-11  01 + (00<<8)                  1          
12-15 02 + (01<<8)                  258        
16-19 00 + (02<<8)                  512        
20-23 01 + (00<<8)                  1          
24-27 00 + (0a<<8)                  2560       
28-31 00 + (00<<8)                  0          
...
44-47 0b + (00<<8) + (01<<8) + (28<<8)  = 0x00010b00 = 4352
48-51 00 + (01<<8)                 256        
52-55 28 + (00<<8)                 40         
56-59 00 + (00<<8)                 0          
60-63 87 + (00<<8)                 135        ⭐
```

## 🎯 關鍵發現

從您的數據中，我看到 `87` 出現在字節 60-63 位置。

根據您提供的數據特徵，這可能是一種 **變長數據格式**。

## 💡 需要您的協助

請告訴我：

### 問題 1: 該 parm 數據代表什麼？
```
您期望的投幣次數: _________
您期望的出獎次數: _________
```

### 問題 2: 對比參考
提供另一組相同機台但數值不同的 parm 數據，例如：
```
parm: "..."
期望投幣: 500
期望出獎: 100
```

這樣可以通過對比找出規律。

## 🔧 臨時解決方案

### 選項 A: 手動指定位置

如果您知道投幣和出獎在哪些字節位置，我可以直接修改代碼。

### 選項 B: 提供多個樣本

給我 3-5 個不同的 parm 樣本和對應的期望值，我可以反向工程出正確的位置。

### 選項 C: 查閱機台文檔

如果您有機台的協議文檔，可以告訴我數據格式。

## 📝 常見機台協議格式

| 格式 | 特點 | 舉例 |
|------|------|------|
| 固定位置 | 數據總是在同一位置 | 位置 16-20 投幣，20-24 出獎 |
| 帶長度前綴 | 每個字段前有長度指示 | `05 123456 03 789` |
| 帶標籤 | 每個字段有標籤 | `01 02030405 02 06070809` |
| TLV 格式 | Tag-Length-Value | `01 04 12345678 02 04 87654321` |

您的 parm 看起來可能是 **帶標籤的變長格式**。

## 🎯 快速測試方法

按 F12 打開控制台，執行以下代碼查看所有可能的組合：

```javascript
const parm = "02020a5e010002010001000201000a00000000000000830628210b000128000087000900d2005e015a00780046000e0128000000140000000000323232320a0a00";

const bytes = [];
for (let i = 0; i < parm.length; i += 2) {
    bytes.push(parseInt(parm.substring(i, i + 2), 16));
}

// 檢查所有可能的 4 字節組合
console.log('=== 所有可能的 Little-Endian 4字節值 ===');
for (let i = 0; i < bytes.length - 3; i++) {
    const val = bytes[i] | (bytes[i+1] << 8) | (bytes[i+2] << 16) | (bytes[i+3] << 24);
    if (val > 0 && val < 1000000) {  // 合理範圍
        console.log(`位置 ${i}-${i+3}: ${val}`);
    }
}

// 特別關注這個值
const val60_63 = bytes[60] | (bytes[61] << 8) | (bytes[62] << 16) | (bytes[63] << 24);
console.log(`\n位置 60-63: ${val60_63} (十六進位: 0x${val60_63.toString(16)})`);
```

## 📞 下一步

請提供：
1. ✅ 您期望該 parm 對應的投幣數
2. ✅ 您期望該 parm 對應的出獎次數
3. ✅ 如果可能，再提供 1-2 個不同的樣本數據

這樣我就能精確找出規律並自動解析！

---

等待您的反饋... 📍
