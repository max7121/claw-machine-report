✅ 位置確認（最終）
==================

## 完整 parm

```
02020a5e010002010001000201000a00000000000000830628210b000128
[在這裡開始]
00870009
[結束]
00d2005e015a00780046000e0128000000140000000000323232320a0a00
```

## 位置計算

從開始到 `00870009` 之前的字符串長度：

```
前面部分: "02020a5e010002010001000201000a00000000000000830628210b000128"

字符數: 64 個字符
字節位置: 64 / 2 = 32

所以 00870009 在位置 32
```

## 驗證

```
parm 完整: 02020a5e010002010001000201000a00000000000000830628210b00012800870009...

位置標記:
0  2    4    6    8    10   12   14   16   18   20   22   24   26   28   30   32   34   36   38
0  2    0a   5e   01   00   02   01   00   01   00   02   01   00   0a   00   00   00   00   00   00
     ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑
     1    2    3    4    5    6    7    8    9    10   11   12   13   14   15   16   17   18   19   20

...
     32   34   36   38
     00   87   00   09
```

## 🎯 正確公式

```
位置 32 = 0x00
位置 33 = 0x87 = 135
位置 34 = 0x00
位置 35 = 0x09 = 9
```

但這給出 135 和 9，不是 350 和 90...

除非... **是 Big-Endian！**

```
(0x00 << 8) | 0x87 = 135 ❌
(0x87 << 8) | 0x00 = 34,560 ❌
```

等等，讓我重新計算...

## 💡 新想法

如果有 `5E 01` 在前面，而實際是 350：

```
5E 01 = 0x015E = 350 (Little-Endian)
```

那麼可能需要往前看一位！

位置 31-32 可能是：
```
位置 30-31: ?? ??
位置 31-32: ?? 00
位置 32-33: 00 87
```

需要完整確認位置 30-35 的字節值。

---

## ✅ 最簡單的方法

改用 **Big-Endian** 試試：

```javascript
const plays = (bytes[36] << 8) | bytes[37];      // 投幣
const payouts = (bytes[38] << 8) | bytes[39];    // 出獎
```

或者往前一位：

```javascript
const plays = (bytes[35] << 8) | bytes[36];      // 投幣
const payouts = (bytes[37] << 8) | bytes[38];    // 出獎
```

先測試 Big-Endian 的位置！
