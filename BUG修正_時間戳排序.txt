==== 🔧 關鍵 BUG 修正：時間戳排序邏輯 ====

【問題診斷】
❌ 之前使用「倒序遍歷」找最新記錄
❌ 但倒序遍歷只是按陣列索引順序反向掃描
❌ 陣列順序未必按時間排序！
❌ 結果：扔掉新的記錄(索引1)，找到舊的記錄(索引94)

【實例】
假設陣列順序:
[0] 2025-10-23 09:48:22 re_stat
[1] 2025-10-23 09:48:11 re_readdata devid=1 ✅ 新的
[2] 2025-10-23 09:48:04 re_stat
...
[94] 2025-10-20 13:27:59 re_readdata devid=1 ❌ 舊的

倒序掃描(從後往前):
[999] ... [95] ... [94] re_readdata devid=1 ← 找到了，但是舊的!

原因: 新的 parm 在索引 1，舊的 parm 在索引 94
倒序掃描最後一個符合的是索引 94 的舊記錄

【修正方案】
✅ 不依賴陣列順序，而是明確使用【時間戳】比對
✅ 先把所有 re_readdata 記錄提取出來
✅ 按 devid 過濾（如果指定了 devid）
✅ 按【時間戳倒序排列】
✅ 取第一個（最新的）

【修正邏輯】

const reReadRecords = [];
// 1️⃣ 提取所有 re_readdata
for (let i = 0; i < data.length; i++) {
    if (是 re_readdata) {
        reReadRecords.push({
            index: i,
            date: '2025-10-23 09:48:11',
            timestamp: 1729654091000,  ← 關鍵：轉換為毫秒時間戳
            devid: 1,
            parsed: {...}
        });
    }
}

// 2️⃣ 按 devid 過濾
let targetRecords = reReadRecords;
if (targetDevid === 1) {
    targetRecords = reReadRecords.filter(r => r.devid == 1);
}

// 3️⃣ 按時間戳倒序排列（最新的在前）
targetRecords.sort((a, b) => b.timestamp - a.timestamp);

// 4️⃣ 取最新的
const newest = targetRecords[0];  ← 100% 是最新的！

【Console 日誌會顯示】
📋 發現所有 re_readdata 記錄:
   [1] 2025-10-23 09:48:11.277 (devid=1)
   [80] 2025-10-20 13:30:04.050 (devid=2)
   [94] 2025-10-20 13:27:59.182 (devid=1)
   [98] 2025-10-20 13:27:xx.xxx (devid=1)
🔎 過濾 devid=1 的記錄，找到 3 條
✅ 選擇最新記錄: [1] 2025-10-23 09:48:11.277 (devid=1)
   時間戳: 1729654091277, 比較其他記錄:
   - [94] 2025-10-20 13:27:59.182
   - [98] 2025-10-20 13:27:xx.xxx

【預期結果】
✅ 系統會正確取得最新的 parm (2025-10-23 09:48:11)
✅ 顯示正確的投幣數: 135 (0x87)
✅ 顯示正確的出貨次數: 9 (0x09)
